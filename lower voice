/*
 * Wio Terminal - LOW RANGE (D2 to E4)
 * This code is for the Wio Terminal responsible for playing the lower notes.
 * It converts absolute MIDI note indices from Python into a relative index
 * to fully utilize the screen space.
 */

#include <TFT_eSPI.h>
#undef min
#undef max
#include <vector>
#include <map>

// TFT screen object
TFT_eSPI tft;

// --- Device-Specific Configuration ---
// Note frequencies for this device's range (D2 to E4)
const int notes[] = {
  // Octave 2 (D2 to B2)
  73, 78, 82, 87, 92, 98, 104, 110, 117, 123,
  // Octave 3 (C3 to B3)
  131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247,
  // Octave 4 (C4 to E4)
  262, 277, 294, 311, 330
};
// Total number of notes this device can play
const int NUM_NOTES = sizeof(notes) / sizeof(int); // Should be 27

// --- CORE FIX: This device's range offset from the project's absolute base note (D2) ---
// D2 (MIDI 38) - D2 (MIDI 38) = 0
const int MY_RANGE_OFFSET = 0;

// Visual and animation parameters
const int RECT_HEIGHT = 8; // Can be a bit taller as there are fewer notes
const int RECT_Y_SPACING = 1;
const int MOVE_SPEED = 60;
const int FRAME_DELAY = 10;
const uint16_t BG_COLOR = TFT_BLACK;

// Rectangle data structure
struct Rect {
  float head_x, tail_x;
  int y;
  uint16_t color;
  bool released;
  int last_draw_x, last_draw_len;
};
std::vector<Rect> rects;

// Map to track the state of each RELATIVE note index
std::map<int, bool> key_states;

// --- setup() function: runs once at startup ---
void setup() {
  Serial.begin(115200);
  tft.begin();
  tft.setRotation(3);
  tft.fillScreen(BG_COLOR);
  pinMode(WIO_BUZZER, OUTPUT);

  // Initialize all key states to false
  for (int i = 0; i < NUM_NOTES; ++i) {
    key_states[i] = false;
  }
}

// --- loop() function: runs repeatedly ---
void loop() {
  // Check for incoming serial data
  while (Serial.available() > 0) {
    int received_byte = Serial.read();
    handle_serial_input(received_byte);
  }
  
  // Update and draw all rectangles
  float deltaX = MOVE_SPEED * (FRAME_DELAY / 1000.0);
  for (int i = rects.size() - 1; i >= 0; i--) {
    Rect &r = rects[i];
    // Erase the previous frame
    tft.fillRect(r.last_draw_x, r.y, r.last_draw_len, RECT_HEIGHT, BG_COLOR);
    
    // Update coordinates based on state
    if (!r.released) {
      r.tail_x = 0;
      r.head_x += deltaX;
    } else {
      r.head_x += deltaX;
      r.tail_x += deltaX;
    }
    
    // Draw the current frame
    int current_draw_x = (int)r.tail_x;
    int current_draw_len = (int)r.head_x - (int)r.tail_x;
    if (current_draw_len > 0) {
      tft.fillRect(current_draw_x, r.y, current_draw_len, RECT_HEIGHT, r.color);
    }
    
    // Store current draw data for the next erase cycle
    r.last_draw_x = current_draw_x;
    r.last_draw_len = current_draw_len;
    
    // Remove rectangles that have moved off-screen
    if (r.tail_x > tft.width()) {
      rects.erase(rects.begin() + i);
    }
  }
  delay(FRAME_DELAY);
}

// --- handle_serial_input() function: processes incoming byte commands ---
void handle_serial_input(int input_byte) {
  if (input_byte == -1) return;

  bool is_press_event = (input_byte < 100);
  // 1. Receive the ABSOLUTE index (0-48) from Python
  int absolute_index = is_press_event ? input_byte : (input_byte - 100);

  // 2. --- CORE FIX: Convert to a RELATIVE index for this device ---
  int relative_index = absolute_index - MY_RANGE_OFFSET;

  // 3. Use the RELATIVE index to check if the note is in this device's range
  if (relative_index < 0 || relative_index >= NUM_NOTES) {
    return; // Ignore notes outside of this device's range
  }

  // 4. Use the RELATIVE index to get the correct frequency from the local 'notes' array
  int note = notes[relative_index];
  
  // 5. --- CORE FIX: Use the RELATIVE index to calculate the Y position ---
  // This makes the visualization start from the top of the screen (y=0)
  int y_pos = relative_index * (RECT_HEIGHT + RECT_Y_SPACING);
  
  uint16_t color = TFT_PINK;

  // Subsequent logic now uses the relative_index
  if (is_press_event) {
    if (!key_states[relative_index]) {
      key_states[relative_index] = true;
      Rect new_rect = {0.0, 0.0, y_pos, color, false, 0, 0};
      rects.push_back(new_rect);
      tone(WIO_BUZZER, note);
    }
  } else {
    if (key_states[relative_index]) {
      key_states[relative_index] = false;
      for (int i = rects.size() - 1; i >= 0; i--) {
        if (rects[i].y == y_pos && !rects[i].released) {
          rects[i].released = true;
          break;
        }
      }
      bool all_keys_up = true;
      for(auto const& [key, val] : key_states) {
        if (val) {
          all_keys_up = false;
          break;
        }
      }
      if (all_keys_up) {
        noTone(WIO_BUZZER);
      }
    }
  }
}
